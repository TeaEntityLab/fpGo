package fpgo

import (
	"time"
)

// ActorDef[T] Actor model inspired by Erlang/Akka
type ActorDef[T any] struct {
	isClosed bool
	ch       *chan T
	effect   func(*ActorDef[T], T)

	context map[string]interface{}

	children map[time.Time]*ActorDef[T]
	parent   *ActorDef[T]
}

var defaultActor *ActorDef[interface{}]

// GetDefault Get Default Actor
func (actorSelf *ActorDef[T]) GetDefault() *ActorDef[interface{}] {
	return defaultActor
}

// New New Actor instance
func (actorSelf *ActorDef[T]) New(effect func(*ActorDef[T], T)) *ActorDef[T] {
	return ActorNewGenerics(effect)
}

// NewByOptions New Actor by its options
func (actorSelf *ActorDef[T]) NewByOptions(effect func(*ActorDef[T], T), ioCh *chan T, context map[string]interface{}) *ActorDef[T] {
	return ActorNewByOptionsGenerics(effect, ioCh, context)
}

// ActorNewGenerics New Actor instance
func ActorNewGenerics[T any](effect func(*ActorDef[T], T)) *ActorDef[T] {
	ch := make(chan T)
	return ActorNewByOptionsGenerics(effect, &ch, map[string]interface{}{})
}

// ActorNewByOptionsGenerics New Actor by its options
func ActorNewByOptionsGenerics[T any](effect func(*ActorDef[T], T), ioCh *chan T, context map[string]interface{}) *ActorDef[T] {
	newOne := ActorDef[T]{ch: ioCh, effect: effect, context: context, children: map[time.Time]*ActorDef[T]{}}
	go newOne.run()

	return &newOne
}

// Send Send a message to the Actor
func (actorSelf *ActorDef[T]) Send(message T) {
	if actorSelf.isClosed {
		return
	}

	*(actorSelf.ch) <- message
}

// Spawn Spawn a new Actor with parent(this actor)
func (actorSelf *ActorDef[T]) Spawn(effect func(*ActorDef[T], T)) *ActorDef[T] {
	newOne := actorSelf.New(effect)
	if actorSelf.isClosed {
		return newOne
	}

	newOne.parent = actorSelf
	actorSelf.children[time.Now()] = newOne

	return newOne
}

// GetChild Get a child Actor by ID
func (actorSelf *ActorDef[T]) GetChild(id time.Time) *ActorDef[T] {
	return actorSelf.children[id]
}

// GetParent Get its parent Actor
func (actorSelf *ActorDef[T]) GetParent() *ActorDef[T] {
	return actorSelf.parent
}

// Close Close the Actor
func (actorSelf *ActorDef[T]) Close() {
	actorSelf.isClosed = true

	close(*actorSelf.ch)
}

// IsClosed Check is Closed
func (actorSelf *ActorDef[T]) IsClosed() bool {
	return actorSelf.isClosed
}

func (actorSelf *ActorDef[T]) run() {
	for message := range *actorSelf.ch {
		actorSelf.effect(actorSelf, message)
	}
}

// Actor Actor utils instance
var Actor ActorDef[interface{}]

func init() {
	Actor = *Actor.New(func(_ *ActorDef[interface{}], _ interface{}) {})
	Actor.Close()
	defaultActor = &Actor
}
