package fpgo

import (
	"sort"
)

// Stream

// StreamDef Stream inspired by Collection utils
type StreamDef[T comparable] []T

// StreamFrom New Stream instance from a T array
func StreamFrom[T comparable](list ...T) *StreamDef[T] {
	return StreamFromArray(list)
}

// StreamFromArray New Stream instance from a T array
func StreamFromArray[T comparable](list []T) *StreamDef[T] {
	result := StreamDef[T](list)
	return &result
}

// StreamFromInterface New Stream instance from an array
func StreamFromInterface(list ...interface{}) *StreamDef[interface{}] {
	return StreamFromArray(list)
}

// StreamFromArrayInterface New Stream instance from an array
func StreamFromArrayInterface(list []interface{}) *StreamDef[interface{}] {
	return StreamFromArray(list)
}

// ToArray Convert Stream to slice
func (streamSelf *StreamDef[T]) ToArray() []T {
	return []T(*streamSelf)
}

// Map Map all items of Stream by function
func (streamSelf *StreamDef[T]) Map(fn func(T, int) T) *StreamDef[T] {

	var result = StreamFromArray(MapIndexed(fn, (*streamSelf)...))

	return result
}

// Filter Filter items of Stream by function
func (streamSelf *StreamDef[T]) Filter(fn func(T, int) bool) *StreamDef[T] {

	var result = StreamFromArray(Filter(fn, (*streamSelf)...))

	return result
}

// Reject Reject items of Stream by function
func (streamSelf *StreamDef[T]) Reject(fn func(T, int) bool) *StreamDef[T] {

	var result = StreamFromArray(Reject(fn, (*streamSelf)...))

	return result
}

// FilterNotNil Filter not nil items and return a new Stream instance
func (streamSelf *StreamDef[T]) FilterNotNil() *StreamDef[T] {
	return streamSelf.Filter(func(val T, i int) bool {
		return Maybe.Just(val).IsPresent()
	})
}

// Distinct Filter duplicated items and return a new Stream instance
func (streamSelf *StreamDef[T]) Distinct() *StreamDef[T] {
	result := StreamDef[T](Distinct[T](*streamSelf...))
	return &result
}

// Contains Check the item exists or not in the Stream
func (streamSelf *StreamDef[T]) Contains(input T) bool {
	return Exists(input, *streamSelf...)
}

// IsSubset returns true or false by checking if stream1 is a subset of stream2
func (streamSelf *StreamDef[T]) IsSubset(input *StreamDef[T]) bool {
	return IsSubset(*streamSelf, *input)
}

// IsSuperset returns true or false by checking if stream1 is a superset of stream2
func (streamSelf *StreamDef[T]) IsSuperset(input *StreamDef[T]) bool {
	return IsSuperset(*streamSelf, *input)
}

// Clone Clone this Stream
func (streamSelf *StreamDef[T]) Clone() *StreamDef[T] {
	result := StreamDef[T](DuplicateSlice[T](*streamSelf))

	return &result
}

// Intersection Get the Intersection with this Stream and an another Stream
func (streamSelf *StreamDef[T]) Intersection(input *StreamDef[T]) *StreamDef[T] {
	result := StreamDef[T](Intersection(*streamSelf, *input))

	return &result
}

// Minus Get all of this Stream but not in the given Stream
func (streamSelf *StreamDef[T]) Minus(input *StreamDef[T]) *StreamDef[T] {
	if input.Len() == 0 {
		return streamSelf
	}

	result := StreamDef[T](Minus(*streamSelf, *input))
	return &result
}

// RemoveItem Remove items from the Stream
func (streamSelf *StreamDef[T]) RemoveItem(input ...T) *StreamDef[T] {
	inputLen := len(input)
	if (inputLen > 0) {
		result := StreamDef[T](Minus(*streamSelf, input))

		return &result
	}

	return streamSelf
}

// Append Append an item to Stream
func (streamSelf *StreamDef[T]) Append(item ...T) *StreamDef[T] {
	return streamSelf.Concat(item)
}

// Remove Remove an item by its index
func (streamSelf *StreamDef[T]) Remove(index int) *StreamDef[T] {
	var result StreamDef[T]
	if index >= 0 && index < streamSelf.Len() {
		result = append((*streamSelf)[:index], (*streamSelf)[index+1:]...)
	} else {
		return streamSelf
	}
	return &result
}

// Len Get length of Stream
func (streamSelf *StreamDef[T]) Len() int {
	return len(*streamSelf)
}

// Concat Concat Stream by another slices
func (streamSelf *StreamDef[T]) Concat(slices ...[]T) *StreamDef[T] {
	if len(slices) == 0 {
		return streamSelf
	}

	return StreamFromArray(Concat(streamSelf.ToArray(), slices...))
}

// Extend Extend Stream by another Stream(s)
func (streamSelf *StreamDef[T]) Extend(streams ...*StreamDef[T]) *StreamDef[T] {
	if len(streams) == 0 {
		return streamSelf
	}

	var mine = *streamSelf
	var mineLen = len(mine)
	var totalLen = mineLen

	for _, stream := range(streams) {
		if stream == nil {
			continue
		}

		var targetLen = len(*stream)
		totalLen += targetLen
	}
	var newOne = make(StreamDef[T], totalLen)

	for i, item := range mine {
		newOne[i] = item
	}
	totalIndex := mineLen

	for _, stream := range(streams) {
		if stream == nil {
			continue
		}

		var target = *stream
		var targetLen = len(target)
		for j, item := range target {
			newOne[totalIndex+j] = item
		}
		totalIndex += targetLen
	}

	return &newOne
}

// Reverse Reverse Stream items
func (streamSelf *StreamDef[T]) Reverse() *StreamDef[T] {
	result := StreamDef[T](Reverse(*streamSelf...))
	return &result
}

// SortByIndex Sort Stream items by function(index, index) bool
func (streamSelf *StreamDef[T]) SortByIndex(fn func(a, b int) bool) *StreamDef[T] {
	result := streamSelf.Clone()
	sort.SliceStable(*result, fn)
	return result
}

// Sort Sort Stream items by Comparator
func (streamSelf *StreamDef[T]) Sort(fn Comparator[T]) *StreamDef[T] {
	result := streamSelf.Clone()
	Sort(fn, *result)
	return result
}

// Get Get an item of Stream by its index
func (streamSelf *StreamDef[T]) Get(i int) T {
	return (*streamSelf)[i]
}

// // Stream Stream utils instance
// var Stream StreamDef[interface{}]

// Set

type SetDef[T comparable] map[T] bool

// SetFrom New Set instance from a T array
func SetFrom[T comparable](list ...T) *SetDef[T] {
	return SetFromArray(list)
}

// SetFromArray New Set instance from a T array
func SetFromArray[T comparable](list []T) *SetDef[T] {
	newOne := SetDef[T](SliceToMap(true, list...))
	return &newOne
}

// SetFromMap New Set instance from a map[T]R
func SetFromMap[T comparable, R any](theMap map[T]R) *SetDef[T] {
	return SetFromArray(Keys(theMap))
}

// SetFromInterface New Set instance from an array
func SetFromInterface(list ...interface{}) *SetDef[interface{}] {
	return SetFromArray(list)
}

// SetFromArrayInterface New Set instance from an array
func SetFromArrayInterface(list []interface{}) *SetDef[interface{}] {
	return SetFromArray(list)
}

// Map Map all items of Set by function
func (setSelf *SetDef[T]) Map(fn TransformerFunctor[T, T]) *SetDef[T] {
	result := make(SetDef[T], len(*setSelf))
	for k := range(*setSelf) {
		result[fn(k)] = true
	}

	return &result
}

// Contains Check the item exists or not in the Set
func (setSelf *SetDef[T]) Contains(input T) bool {
	_, ok := (*setSelf)[input]
	return ok
}

// IsSubset returns true or false by checking if set1 is a subset of set2
func (setSelf *SetDef[T]) IsSubset(input *SetDef[T]) bool {
	return IsSubsetMapByKey(*setSelf, *input)
}

// IsSuperset returns true or false by checking if set1 is a superset of set2
func (setSelf *SetDef[T]) IsSuperset(input *SetDef[T]) bool {
	return IsSupersetMapByKey(*setSelf, *input)
}

// Add Add items into the Set
func (setSelf *SetDef[T]) Add(input ...T) *SetDef[T] {
	inputLen := len(input)
	if (inputLen > 0) {
		result := setSelf.Clone()
		for _, v := range(input) {
			if _, ok := (*result)[v]; ok {
				continue
			}
			(*result)[v] = true
		}

		return result
	}

	return setSelf
}

// Remove Remove items from the Set
func (setSelf *SetDef[T]) Remove(input ...T) *SetDef[T] {
	inputLen := len(input)
	if (inputLen > 0) {
		result := setSelf.Clone()
		for _, v := range(input) {
			delete(*result, v)
		}

		return result
	}

	return setSelf
}

// Clone Clone this Set
func (setSelf *SetDef[T]) Clone() *SetDef[T] {
	result := SetDef[T](DuplicateMap[T, bool](*setSelf))

	return &result
}

// Union Union an another Set object
func (setSelf *SetDef[T]) Union(input *SetDef[T]) *SetDef[T] {
	result := SetDef[T](Merge(*setSelf, *input))

	return &result
}

// Intersection Get the Intersection with this Set and an another Set
func (setSelf *SetDef[T]) Intersection(input *SetDef[T]) *SetDef[T] {
	result := SetDef[T](IntersectionMapByKey(*setSelf, *input))

	return &result
}

// Minus Get all of this Set but not in the given Set
func (setSelf *SetDef[T]) Minus(input *SetDef[T]) *SetDef[T] {
	if input.Size() == 0 {
		return setSelf
	}

	result := setSelf.Clone()
	for k := range(*result) {
		_, exists := (*input)[k]
		if exists {
			delete(*result, k)
		}
	}

	return result
}

// Size Get size
func (setSelf *SetDef[T]) Size() int {
	return len(*setSelf)
}

// ToArray Convert Set to slice
func (setSelf *SetDef[T]) ToArray() []T {
	return Keys(*setSelf)
}

// // Set Set utils instance
// var Set SetDef[interface{}]
